/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
import * as vscode from 'vscode';
import { Message, MessageParticipant, MessengerAPI, NotificationHandler, NotificationMessage, NotificationType, RequestHandler, RequestMessage, RequestType, ResponseError, ResponseMessage } from 'vscode-messenger-common';
export declare class Messenger implements MessengerAPI {
    protected readonly idProvider: IdProvider;
    protected readonly viewTypeRegistry: Map<string, Set<ViewContainer>>;
    protected readonly viewRegistry: Map<string, ViewData>;
    protected readonly handlerRegistry: Map<string, RequestHandler<unknown, unknown> | NotificationHandler<unknown>>;
    protected readonly requests: Map<string, RequestData>;
    protected readonly options: MessengerOptions;
    constructor(options?: MessengerOptions);
    registerWebviewPanel(panel: vscode.WebviewPanel, options?: ViewOptions): void;
    registerWebviewView(view: vscode.WebviewView, options?: ViewOptions): void;
    protected registerViewContainer(view: ViewContainer, options: ViewOptions): void;
    /**
     * Process an incoming message by forwarding it to the respective receiver or handling it with
     * a locally registered message handler.
     */
    protected processMessage(msg: Message, responseCallback: (res: Message) => Thenable<boolean>): Promise<void>;
    /**
     * Process an incoming request message with a registered handler.
     */
    protected processRequestMessage(msg: RequestMessage, responseCallback: (res: Message) => Thenable<boolean>): Promise<void>;
    protected createResponseError(error: unknown): ResponseError;
    /**
     * Process an incoming notification message with a registered handler.
     */
    protected processNotificationMessage(msg: NotificationMessage): Promise<void>;
    /**
     * Process an incoming response message by resolving or rejecting the associated promise.
     */
    protected processResponseMessage(msg: ResponseMessage): Promise<void>;
    onRequest<P, R>(type: RequestType<P, R>, handler: RequestHandler<P, R>): void;
    onNotification<P>(type: NotificationType<P>, handler: NotificationHandler<P>): void;
    sendRequest<P, R>(type: RequestType<P, R>, receiver: MessageParticipant, params: P): Promise<R>;
    protected sendRequestToWebview<P, R>(type: RequestType<P, R>, receiver: MessageParticipant, params: P, view: ViewContainer): Promise<R>;
    sendNotification<P>(type: NotificationType<P>, receiver: MessageParticipant, params: P): void;
    protected sendNotificationToWebview<P>(type: NotificationType<P>, receiver: MessageParticipant, params: P, view: ViewContainer): Promise<void>;
    private nextMsgId;
    protected createMsgId(): string;
    protected log(text: string, level?: 'debug' | 'warn' | 'error'): void;
}
export declare type ViewContainer = vscode.WebviewPanel | vscode.WebviewView;
export interface MessengerOptions {
    /** A message is ignored if the receiver is a webview that is currently hidden (not visible). */
    ignoreHiddenViews?: boolean;
    /** Whether to log any debug-level messages to the console. */
    debugLog?: boolean;
}
export interface RequestData {
    resolve: (value: unknown) => void;
    reject: (reason?: any) => void;
}
export interface ViewData {
    id: string;
    container: ViewContainer;
    options: ViewOptions;
}
export interface ViewOptions {
    /**
     * Methods to be received by the webview when corresponding notifications are sent with
     * a `broadcast` type. If omitted, no broadcast notifications will be received.
     */
    broadcastMethods?: string[];
}
declare class IdProvider {
    private counter;
    /**
     * Provide an identifier for the given webview. This should be called only once per webview
     * instance because the result will be different for every call.
     */
    getWebviewId(view: ViewContainer): string;
}
export {};
//# sourceMappingURL=messenger.d.ts.map