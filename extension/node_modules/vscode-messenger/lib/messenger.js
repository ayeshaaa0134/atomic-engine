"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Messenger = void 0;
const vscode_messenger_common_1 = require("vscode-messenger-common");
class Messenger {
    constructor(options) {
        this.idProvider = new IdProvider();
        this.viewTypeRegistry = new Map();
        this.viewRegistry = new Map();
        this.handlerRegistry = new Map();
        this.requests = new Map();
        this.nextMsgId = 0;
        const defaultOptions = {
            ignoreHiddenViews: true,
            debugLog: false
        };
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
    }
    registerWebviewPanel(panel, options = {}) {
        this.registerViewContainer(panel, options);
    }
    registerWebviewView(view, options = {}) {
        this.registerViewContainer(view, options);
    }
    registerViewContainer(view, options) {
        // Register typed view
        const viewTypeEntry = this.viewTypeRegistry.get(view.viewType);
        if (viewTypeEntry) {
            viewTypeEntry.add(view);
        }
        else {
            this.viewTypeRegistry.set(view.viewType, new Set([view]));
        }
        // Add viewId mapping
        const viewEntry = {
            id: this.idProvider.getWebviewId(view),
            container: view,
            options
        };
        this.viewRegistry.set(viewEntry.id, viewEntry);
        view.onDidDispose(() => {
            var _a;
            this.viewRegistry.delete(viewEntry.id);
            const removed = (_a = this.viewTypeRegistry.get(view.viewType)) === null || _a === void 0 ? void 0 : _a.delete(view);
            if (!removed) {
                this.log(`Attempt to remove non-existing registry entry for View: ${view.title} (type ${view.viewType})`, 'warn');
            }
        });
        view.webview.onDidReceiveMessage((msg) => __awaiter(this, void 0, void 0, function* () {
            if ((0, vscode_messenger_common_1.isMessage)(msg)) {
                if (!msg.sender) {
                    msg.sender = {
                        type: 'webview',
                        webviewId: viewEntry.id,
                        webviewType: view.viewType
                    };
                }
                return this.processMessage(msg, res => view.webview.postMessage(res))
                    .catch(err => this.log(String(err), 'error'));
            }
        }));
    }
    /**
     * Process an incoming message by forwarding it to the respective receiver or handling it with
     * a locally registered message handler.
     */
    processMessage(msg, responseCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (msg.receiver.type === 'extension') {
                // The message is directed to this host extension
                if ((0, vscode_messenger_common_1.isRequestMessage)(msg)) {
                    yield this.processRequestMessage(msg, responseCallback);
                }
                else if ((0, vscode_messenger_common_1.isNotificationMessage)(msg)) {
                    yield this.processNotificationMessage(msg);
                }
                else if ((0, vscode_messenger_common_1.isResponseMessage)(msg)) {
                    yield this.processResponseMessage(msg);
                }
                else {
                    this.log(`Invalid message: ${JSON.stringify(msg)}`, 'error');
                }
            }
            else if (msg.receiver.type === 'webview') {
                if (msg.receiver.webviewId) {
                    // The message is directed to a specific webview
                    const receiverView = this.viewRegistry.get(msg.receiver.webviewId);
                    if (receiverView) {
                        const result = yield receiverView.container.webview.postMessage(msg);
                        if (!result) {
                            this.log(`Failed to forward message to view: ${msg.receiver.webviewId}`, 'error');
                        }
                    }
                    else {
                        this.log(`No webview with id ${msg.receiver.webviewId} is registered.`, 'warn');
                    }
                }
                else if (msg.receiver.webviewType) {
                    // The message is directed to all webviews of a specific type
                    const receiverViews = this.viewTypeRegistry.get(msg.receiver.webviewType);
                    if (receiverViews) {
                        receiverViews.forEach((view) => __awaiter(this, void 0, void 0, function* () {
                            const result = yield view.webview.postMessage(msg);
                            if (!result) {
                                this.log(`Failed to forward message to view: ${msg.receiver.webviewType}`, 'error');
                            }
                        }));
                    }
                    else {
                        this.log(`No webview with type ${msg.receiver.webviewType} is registered.`, 'warn');
                    }
                }
                else {
                    this.log(`A receiver of type 'webview' must specify a 'webviewId' or a 'webviewType': ${JSON.stringify(msg)}`, 'error');
                }
            }
            else if (msg.receiver.type === 'broadcast') {
                if ((0, vscode_messenger_common_1.isNotificationMessage)(msg)) {
                    // The notification is broadcasted to all enabled webviews and to this extension
                    for (const view of this.viewRegistry.values()) {
                        if (view.options.broadcastMethods && view.options.broadcastMethods.indexOf(msg.method) >= 0) {
                            view.container.webview.postMessage(msg);
                        }
                    }
                    yield this.processNotificationMessage(msg);
                }
                else {
                    this.log(`Only notification messages are allowed for broadcast: ${JSON.stringify(msg)}`, 'error');
                }
            }
        });
    }
    /**
     * Process an incoming request message with a registered handler.
     */
    processRequestMessage(msg, responseCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log(`Host received Request message: ${msg.method} (id ${msg.id})`);
            const handler = this.handlerRegistry.get(msg.method);
            if (!handler) {
                this.log(`Received request with unknown method: ${msg.method}`, 'warn');
                const response = {
                    id: msg.id,
                    sender: vscode_messenger_common_1.HOST_EXTENSION,
                    receiver: msg.sender,
                    error: {
                        message: `Unknown method: ${msg.method}`
                    }
                };
                yield responseCallback(response);
                return;
            }
            try {
                const result = yield handler(msg.params, msg.sender);
                const response = {
                    id: msg.id,
                    sender: vscode_messenger_common_1.HOST_EXTENSION,
                    receiver: msg.sender,
                    result: result
                };
                const posted = yield responseCallback(response);
                if (!posted) {
                    this.log(`Failed to send result message: ${participantToString(response.receiver)}`, 'error');
                }
            }
            catch (error) {
                const response = {
                    id: msg.id,
                    sender: vscode_messenger_common_1.HOST_EXTENSION,
                    receiver: msg.sender,
                    error: this.createResponseError(error)
                };
                const posted = yield responseCallback(response);
                if (!posted) {
                    this.log(`Failed to send error message: ${participantToString(response.receiver)}`, 'error');
                }
            }
        });
    }
    createResponseError(error) {
        if (error instanceof Error) {
            return { message: error.message, data: error.stack };
        }
        else if (typeof error === 'object' && error !== null && typeof error.message === 'string') {
            return { message: error.message, data: error.data };
        }
        else {
            return { message: String(error) };
        }
    }
    /**
     * Process an incoming notification message with a registered handler.
     */
    processNotificationMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log(`Host received Notification message: ${msg.method}`);
            const handler = this.handlerRegistry.get(msg.method);
            if (handler) {
                yield handler(msg.params, msg.sender);
            }
            else if (msg.receiver.type !== 'broadcast') {
                this.log(`Received notification with unknown method: ${msg.method}`, 'warn');
            }
        });
    }
    /**
     * Process an incoming response message by resolving or rejecting the associated promise.
     */
    processResponseMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log(`Host received Response message: ${msg.id} `);
            const request = this.requests.get(msg.id);
            if (request) {
                if (msg.error) {
                    request.reject(msg.error);
                }
                else {
                    request.resolve(msg.result);
                }
                this.requests.delete(msg.id);
            }
            else {
                this.log(`Received response for untracked message id: ${msg.id} (participant: ${participantToString(msg.sender)})`, 'warn');
            }
        });
    }
    onRequest(type, handler) {
        if (this.handlerRegistry.has(type.method)) {
            this.log(`A request handler is already registered for method ${type.method} and will be overridden.`, 'warn');
        }
        this.handlerRegistry.set(type.method, handler);
    }
    onNotification(type, handler) {
        if (this.handlerRegistry.has(type.method)) {
            this.log(`A notification handler is already registered for method ${type.method} and will be overridden.`, 'warn');
        }
        this.handlerRegistry.set(type.method, handler);
    }
    sendRequest(type, receiver, params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (receiver.type === 'extension') {
                throw new Error('Requests to other extensions are not supported yet.');
            }
            else if (receiver.type === 'webview') {
                if (receiver.webviewId) {
                    const receiverView = this.viewRegistry.get(receiver.webviewId);
                    if (receiverView) {
                        return this.sendRequestToWebview(type, receiver, params, receiverView.container);
                    }
                    else {
                        return Promise.reject(new Error(`No webview with id ${receiver.webviewId} is registered.`));
                    }
                }
                else if (receiver.webviewType) {
                    const receiverViews = this.viewTypeRegistry.get(receiver.webviewType);
                    if (receiverViews) {
                        // If there are multiple views, we make a race: the first view to return a result wins
                        const results = Array.from(receiverViews).map(view => this.sendRequestToWebview(type, receiver, params, view));
                        return Promise.race(results);
                    }
                    else {
                        return Promise.reject(new Error(`No webview with type ${receiver.webviewType} is registered.`));
                    }
                }
                else {
                    throw new Error('Unspecified webview receiver: neither webviewId nor webviewType was set.');
                }
            }
            else if (receiver.type === 'broadcast') {
                throw new Error('Only notification messages are allowed for broadcast.');
            }
            throw new Error(`Invalid receiver: ${JSON.stringify(receiver)}`);
        });
    }
    sendRequestToWebview(type, receiver, params, view) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Messages are only delivered if the webview is live (either visible or in the background with `retainContextWhenHidden`).
            if (!view.visible && this.options.ignoreHiddenViews) {
                return Promise.reject(new Error(`Skipped request for hidden view: ${participantToString(receiver)}`));
            }
            const msgId = this.createMsgId();
            const result = new Promise((resolve, reject) => {
                this.requests.set(msgId, { resolve: resolve, reject });
            });
            const message = {
                id: msgId,
                method: type.method,
                sender: vscode_messenger_common_1.HOST_EXTENSION,
                receiver,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                params: params
            };
            const posted = yield view.webview.postMessage(message);
            if (!posted) {
                this.log(`Failed to send message to view: ${participantToString(receiver)}`, 'error');
                (_a = this.requests.get(msgId)) === null || _a === void 0 ? void 0 : _a.reject(new Error(`Failed to send message to view: ${participantToString(receiver)}`));
                this.requests.delete(msgId);
            }
            return result;
        });
    }
    sendNotification(type, receiver, params) {
        if (receiver.type === 'extension') {
            throw new Error('Notifications to other extensions are not supported yet.');
        }
        else if (receiver.type === 'webview') {
            if (receiver.webviewId) {
                const receiverView = this.viewRegistry.get(receiver.webviewId);
                if (receiverView) {
                    this.sendNotificationToWebview(type, receiver, params, receiverView.container)
                        .catch(err => this.log(String(err), 'error'));
                }
                else {
                    this.log(`No webview with id ${receiver.webviewId} is registered.`, 'warn');
                }
            }
            else if (receiver.webviewType) {
                const receiverViews = this.viewTypeRegistry.get(receiver.webviewType);
                if (receiverViews) {
                    receiverViews.forEach(view => {
                        this.sendNotificationToWebview(type, receiver, params, view)
                            .catch(err => this.log(String(err), 'error'));
                    });
                }
                else {
                    this.log(`No webview with type ${receiver.webviewType} is registered.`, 'warn');
                }
            }
            else {
                throw new Error('Unspecified webview receiver: neither webviewId nor webviewType was set.');
            }
        }
        else if (receiver.type === 'broadcast') {
            for (const view of this.viewRegistry.values()) {
                if (view.options.broadcastMethods && view.options.broadcastMethods.indexOf(type.method) >= 0) {
                    this.sendNotificationToWebview(type, receiver, params, view.container)
                        .catch(err => this.log(String(err), 'error'));
                }
            }
        }
    }
    sendNotificationToWebview(type, receiver, params, view) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!view.visible && this.options.ignoreHiddenViews) {
                this.log(`Skipped notification for hidden view: ${participantToString(receiver)}`, 'warn');
                return;
            }
            const message = {
                method: type.method,
                sender: vscode_messenger_common_1.HOST_EXTENSION,
                receiver,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                params: params
            };
            const result = yield view.webview.postMessage(message);
            if (!result) {
                this.log(`Failed to send message to view: ${participantToString(receiver)}`, 'error');
            }
        });
    }
    createMsgId() {
        return 'req_' + this.nextMsgId++;
    }
    log(text, level = 'debug') {
        switch (level) {
            case 'debug': {
                if (this.options.debugLog) {
                    console.debug(text);
                }
                break;
            }
            case 'warn': {
                console.warn(text);
                break;
            }
            case 'error': {
                console.error(text);
                break;
            }
        }
    }
}
exports.Messenger = Messenger;
class IdProvider {
    constructor() {
        this.counter = 0;
    }
    /**
     * Provide an identifier for the given webview. This should be called only once per webview
     * instance because the result will be different for every call.
     */
    getWebviewId(view) {
        return view.viewType + '_' + this.counter++;
    }
}
function participantToString(participant) {
    switch (participant.type) {
        case 'extension':
            return 'host extension';
        case 'webview':
            if (participant.webviewId) {
                return participant.webviewId;
            }
            else if (participant.webviewType) {
                return participant.webviewType;
            }
            else {
                return 'unspecified webview';
            }
        case 'broadcast':
            return 'broadcast';
    }
}
//# sourceMappingURL=messenger.js.map